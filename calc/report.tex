\documentclass[a4paper]{jsarticle}
\usepackage{amsmath,amsfonts}
\usepackage{bm}
\usepackage{siunitx}
\usepackage[dvipdfmx]{graphicx}
\usepackage[dvipdfmx]{color}
\usepackage{listings}
\usepackage{ascmac,url}

\newcommand{\var}[1]{\texttt{#1}}

\begin{document}
\begin{titlepage}
\begin{center}
\vspace*{150truept}
{\huge アセンブリ言語 期末課題 レポート}\par
\vspace{50truept}
{\large 講義名:アセンブリ言語}\par
\vspace{5truept}
{\large 学籍番号:23B30032}\par
\vspace{5truept}
{\large 氏名:飯田悠太}\par
\vspace{5truept}
{\large 作成日:\today}
\end{center}
\end{titlepage}
本レポートは，アセンブリ言語の期末課題であるcalc0からcalc3までの4つのバージョンの電卓コンパイラそれぞれについて，実装方法とその工夫，考察について述べるものである。
\section{calc0}
この章ではcalc0の実装，つまり課題であるcalc1からcalc3までのアセンブリを出力するベースとなるCのコードについて述べる。
\subsection{全体の実装}
入力された式については\var{p}というポインタ型の変数に格納し，これを先頭から１文字ずつ\var{while}で読んでいくことにより，電卓の入力を１文字ずつ読んでいくということを再現した。

入力された要素については，数字，演算子，メモリキー，符号反転キーの4つに分類して処理することにした。また，演算結果を処理するための変数として，現在入力されている数値を管理する変数\var{num}と，演算子を管理する変数\var{lastOp}，現在までの計算結果を管理する変数\var{acc}，メモリ機能の値を管理する変数\var{mem}，符号反転キーが入力された回数を管理する変数\var{countS}を用意した。

以下，入力要素の種類ごとの処理について述べる。
\subsubsection{数値の管理}
数値については，数字が入力されるたびに既存の\var{num}を10倍し，それに現在見ている数字\var{*p}から'0'を引いたものを加えることで，数値を管理することにした。これは，10進数の数値の表現方法をそのまま利用したものであり，簡単に理解することができる。文字型から数値への変換には，数字に連続されたコードが与えられるというASCIIコードの性質を利用している。

\subsubsection{演算子の管理}
もし現在見ている文字が演算子(\var{+}, \var{-}, \var{*}, \var{/}, \var{=})である場合，まず見ている文字の次の文字が演算子でなくなるまでポインタを進める。これは，電卓で言うところの「最後に入力された記号キー」を拾ってきて，それ以外の演算子の入力は無視する，という動作を実現するためである。

演算子の入力が確定した時点で，今入力された演算子ではなく，元々持っていた演算子で計算を行う。これは，演算を行うためには，演算子の前までの計算値と演算子の直後にくる数値の2つが必要であるが，演算子を見た時点では演算子直後の数値が確定していないので，代わりに前回の演算子の前までの計算値と前回の演算子，そして前回の演算子直後の数値を用いて計算する必要があるからである。それゆえ，\var{lastOp}の初期値は\var{+}としておく必要がある。なぜならば，式中で初めて演算子を見た時に行うべき計算は\var{acc}に\var{num}を代入するという操作であり，その操作は\var{acc}の初期値0に\var{num}を加えるという操作と等価であるからである。

また，符号の反転については，\var{num}の符号について，\var{countS}が偶数の時には符号を反転し，奇数の時には反転しないようにすることで，符号反転キーが押された回数に応じて符号を反転することができる。

計算を終えた後，現在見ている演算子を\var{lastOp}に代入し，\var{num}，\var{countS}を0にリセットする。これにより，次の数値の入力に備えることができる。

\subsubsection{メモリ機能の管理}
メモリ管理機能について，まず，\var{C}が入力された場合は\var{mem}に\var{acc}の値を代入し，\var{R}が入力された場合は，\var{acc}に\var{mem}の値を代入するようにしている。これらは非常にシンプルである。

次に，\var{P}，つまりメモリ加算キーが入力された場合について考える。この場合，まず\var{P}が入力される前までの演算結果を用意する必要があるので，\var{P}が入力された時点での\var{acc}, \var{num}, \var{lastOp}, \var{countS}の値に基づいて演算を行う。そしてその値を\var{mem}に加算する。これにより，メモリ加算キーが入力された時点までの計算結果をメモリに保存することができる。すると，\var{mem}以外の各種変数が保持している値はもはや必要がなくなる(なぜならばメモリに保存されているから)ので，これらは全て初期値にリセットする。

\var{M}，つまりメモリ減算キーが入力された場合の動作は，\var{mem}への加算が減算に変わるだけで，\var{P}の場合とほぼ同様の処理を行うことで実現できる。

\subsection{実装の工夫点}
この実装で工夫した点は\var{lastOp}の初期値を\var{+}にした上で，演算子を遅延処理するようにしたことである。これにより，最初の数値入力も含めて全て同一の方法で処理することができ，コードの可読性向上につながっている。

\section{calc1}
この章ではcalc1の実装について述べる。なお，実装のベースの考え方はcalc0と同様であるので，本章ではcalc0でのC言語ベースの実装をどのようにアセンブリに落とし込んだかについて述べる。

\subsection{変数の取り扱い}
まず，課題のレギュレーションの制約上，calc0ではC言語の変数として管理していた\var{num}, \var{acc}, \var{mem}, \var{countS}を，アセンブリで管理する必要がある。そこで，\var{acc}はレジスタ\var{eax}, \var{num}はレジスタ\var{ecx}で管理し，\var{mem}と\var{countS}はスタックで管理することにした。

このように設計した理由を述べる。そもそも，アセンブリコードを書き始めた時はこれら4つの変数は全てレジスタで管理していた。しかしながら，コードを書き進めるうちに，使用するアセンブリが混雑してきたり，誤ってcallee-saveなレジスタをスタックへの退避なしで使用してしますミスが発生してしまったりすることがあると気づいた。そこで，比べて使用頻度の少ない\var{mem}と\var{countS}をスタックで管理し，使用するタイミングでのみスタックから取り出して空いているレジスタに読み込んだり，直接アドレスを参照するようにした。また，\var{num}と\var{acc}に割り当てるレジスタの選定であるが，\var{acc}は最終的な式の計算結果が格納されることが期待されるため，関数の返り値の格納に使われる\var{eax}を使用することにした。\var{num}を格納するレジスタについては，caller-saveなレジスタのうち\var{eax}でないもの，という理由で\var{ecx}を選択した。

以上のような理由で変数の取り扱い法を設計した。

\subsection{数値の管理}
数値の取り扱いについては，calc0で説明した実装を単純にアセンブリに置き換えて行ったのみである。

\subsection{演算子の管理}
演算子の管理について，まず\var{lastOp}についてはレギュレーション上C言語での管理が認められていたので，calc0通りの実装のまま行った。

それ以降の処理について述べる。まず初めに符号反転キーの行うことにした。符号反転キーが押された回数は常にスタックの上から２番目に置かれているので，これを空いている\var{rdx}レジスタに読み込む。その後\var{testb}命令を使うことにより，$\var{rdx} \&\& 1$の結果が0であるかどうか，つまり符号反転キーが押された回数が偶数か奇数かを判定するようにした。これにより，ゼロフラグがセットされている時，つまり符号反転キーが偶数回押されている時は数値の符号を反転させる\var{negl}命令をジャンプするようにした。以上のようにして，符号反転キーの処理を行った。

また，その後の演算は\var{lastOp}に記録された演算子に対応するアセンブリ命令を用いるだけであるが，割り算の場合においては若干実装に工夫があるので，それについて述べる。
割り算のとき，負数の取り扱いのために符号拡張を行う必要がある。講義資料では\var{eax}レジスタの正負に合わせて\var{mov}命令により\var{edx}の上位ビットをセットする方法が紹介されていたが，今回は\var{cltd}命令を用いた。これにより，割り算の際に\var{eax}の符号に合わせて\var{mov}命令でセットする値を変更する，というコードを書かなくて良くなり，コードが簡潔になった。

% り，そのための前準備として，レジスタ\var{rdx}の値のクリアを行う必要がある。これを単に\var{movl \$0, \%rdx}とせず，\var{xorl}命令を用いて実装したのが工夫である。このような工夫をした理由として，アセンブリにおいては，単に即値0を代入するよりも\var{xorl}命令を用いる方が高速であるという知見を得たからである。また，そのような背景があるため0クリアには\var{xorl}命令を用いることが一般的であるという言説を聞き，慣例に則った方がより読み手に理解されやすいだろうと思い\var{xorl}を用いたという側面もある。






\section{calc2}
todo
\section{calc3}
todo
\section{反省}
- 命令やレジスタが本当に高速になっているのかを計測して確かめていない。
\end{document}