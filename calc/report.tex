\documentclass[a4paper]{jsarticle}
\usepackage{amsmath,amsfonts}
\usepackage{bm}
\usepackage{siunitx}
\usepackage[dvipdfmx]{graphicx}
\usepackage[dvipdfmx]{color}
\usepackage{listings}
\usepackage{ascmac,url}

\newcommand{\var}[1]{\texttt{#1}}

\begin{document}
\begin{titlepage}
\begin{center}
\vspace*{150truept}
{\huge アセンブリ言語 期末課題 レポート}\par
\vspace{50truept}
{\large 講義名:アセンブリ言語}\par
\vspace{5truept}
{\large 学籍番号:23B30032}\par
\vspace{5truept}
{\large 氏名:飯田悠太}\par
\vspace{5truept}
{\large 作成日:\today}
\end{center}
\end{titlepage}
本レポートは，アセンブリ言語の期末課題であるcalc0からcalc3までの4つのバージョンの電卓コンパイラそれぞれについて，実装方法とその工夫，考察について述べるものである。
\section{calc0}
この章ではcalc0の実装，つまり課題であるcalc1からcalc3までのアセンブリを出力するベースとなるCのコードについて述べる。
\subsection{全体の実装}
入力された式については\var{p}というポインタ型の変数に格納し，これを先頭から１文字ずつ\var{while}で読んでいくことにより，電卓の入力を１文字ずつ読んでいくということを再現した。

入力された要素については，数字，演算子，メモリキー，符号反転キーの4つに分類して処理することにした。また，演算結果を処理するための変数として，現在入力されている数値を管理する変数\var{num}と，演算子を管理する変数\var{lastOp}，現在までの計算結果を管理する変数\var{acc}，メモリ機能の値を管理する変数\var{mem}，符号反転キーが入力された回数を管理する変数\var{countS}を用意した。

以下，入力要素の種類ごとの処理について述べる。
\subsubsection{数値の管理}
数値については，数字が入力されるたびに既存の\var{num}を10倍し，それに現在見ている数字\var{*p}から'0'を引いたものを加えることで，数値を管理することにした。これは，10進数の数値の表現方法をそのまま利用したものであり，簡単に理解することができる。文字型から数値への変換には，数字に連続されたコードが与えられるというASCIIコードの性質を利用している。

\subsubsection{演算子の管理}
もし現在見ている文字が演算子(\var{+}, \var{-}, \var{*}, \var{/}, \var{=})である場合，まず見ている文字の次の文字が演算子でなくなるまでポインタを進める。これは，電卓で言うところの「最後に入力された記号キー」を拾ってきて，それ以外の演算子の入力は無視する，という動作を実現するためである。

演算子の入力が確定した時点で，今入力された演算子ではなく，元々持っていた演算子で計算を行う。これは，演算を行うためには，演算子の前までの計算値と演算子の直後にくる数値の2つが必要であるが，演算子を見た時点では演算子直後の数値が確定していないので，代わりに前回の演算子の前までの計算値と前回の演算子，そして前回の演算子直後の数値を用いて計算する必要があるからである。それゆえ，\var{lastOp}の初期値は\var{+}としておく必要がある。なぜならば，式中で初めて演算子を見た時に行うべき計算は\var{acc}に\var{num}を代入するという操作であり，その操作は\var{acc}の初期値0に\var{num}を加えるという操作と等価であるからである。

また，符号の反転については，\var{num}の符号について，\var{countS}が偶数の時には符号を反転し，奇数の時には反転しないようにすることで，符号反転キーが押された回数に応じて符号を反転することができる。

計算を終えた後，現在見ている演算子を\var{lastOp}に代入し，\var{num}，\var{countS}を0にリセットする。これにより，次の数値の入力に備えることができる。

\subsubsection{メモリ機能の管理}
メモリ管理機能について，まず，\var{C}が入力された場合は\var{mem}に\var{acc}の値を代入し，\var{R}が入力された場合は，\var{acc}に\var{mem}の値を代入するようにしている。これらは非常にシンプルである。

次に，\var{P}，つまりメモリ加算キーが入力された場合について考える。この場合，まず\var{P}が入力される前までの演算結果を用意する必要があるので，\var{P}が入力された時点での\var{acc}, \var{num}, \var{lastOp}, \var{countS}の値に基づいて演算を行う。そしてその値を\var{mem}に加算する。これにより，メモリ加算キーが入力された時点までの計算結果をメモリに保存することができる。すると，\var{mem}以外の各種変数が保持している値はもはや必要がなくなる(なぜならばメモリに保存されているから)ので，これらは全て初期値にリセットする。

\var{M}，つまりメモリ減算キーが入力された場合の動作は，\var{mem}への加算が減算に変わるだけで，\var{P}の場合とほぼ同様の処理を行うことで実現できる。

\subsection{実装の工夫点}
この実装で工夫した点は\var{lastOp}の初期値を\var{+}にした上で，演算子を遅延処理するようにしたことである。これにより，最初の数値入力も含めて全て同一の方法で処理することができ，コードの可読性向上につながっている。

\section{calc1}
この章ではcalc1の実装について述べる。なお，実装のベースの考え方はcalc0と同様であるので，本章ではcalc0でのC言語ベースの実装をどのようにアセンブリに落とし込んだかについて述べる。

\subsection{変数の取り扱い}
まず，課題のレギュレーションの制約上，calc0ではC言語の変数として管理していた\var{num}, \var{acc}, \var{mem}, \var{countS}を，アセンブリで管理する必要がある。そこで，\var{acc}はレジスタ\var{eax}, \var{num}はレジスタ\var{ecx}で管理し，\var{mem}と\var{countS}はスタックで管理することにした。

このように設計した理由を述べる。そもそも，アセンブリコードを書き始めた時はこれら4つの変数は全てレジスタで管理していた。しかしながら，コードを書き進めるうちに，使用するアセンブリが混雑してきたり，誤ってcallee-saveなレジスタをスタックへの退避なしで使用してしますミスが発生してしまったりすることがあると気づいた。そこで，比べて使用頻度の少ない\var{mem}と\var{countS}をスタックで管理し，使用するタイミングでのみスタックから取り出して空いているレジスタに読み込んだり，直接アドレスを参照するようにした。また，\var{num}と\var{acc}に割り当てるレジスタの選定であるが，\var{acc}は最終的な式の計算結果が格納されることが期待されるため，関数の返り値の格納に使われる\var{eax}を使用することにした。\var{num}を格納するレジスタについては，caller-saveなレジスタのうち\var{eax}でないもの，という理由で\var{ecx}を選択した。

また，このコード上では変数に0を代入する操作を頻繁に行うが，多くの部分で単に\var{mov}命令で即値0を代入するのではなく，\var{xor}命令を用いて0クリアを行うようにした。これは，\var{mov}命令による即値代入よりも\var{xor}命令を用いた方が高速であるという知見を得たからである。また，そのような背景があるため0クリアには\var{xor}命令を用いることが一般的であるという言説を聞き，慣例に則った方がより読み手に理解されやすいだろうと思い\var{xor}を用いたという側面もある。これもコードの工夫と言えるだろう。

\subsection{数値の管理}
数値の取り扱いについては，calc0で説明した実装を単純にアセンブリに置き換えて行ったのみである。

\subsection{演算子の管理}
演算子の管理について，まず\var{lastOp}についてはレギュレーション上C言語での管理が認められていたので，calc0通りの実装のまま行った。

それ以降の処理について述べる。まず初めに符号反転キーの処理を行うことにした。符号反転キーが押された回数は常にスタックの上から２番目に置かれているので，これを空いている\var{rdx}レジスタに読み込む。その後\var{testb}命令を使うことにより，$\var{rdx} \&\& 1$の結果が0であるかどうか，つまり符号反転キーが押された回数が偶数か奇数かを判定するようにした。これにより，ゼロフラグがセットされている時，つまり符号反転キーが偶数回押されている時は数値の符号を反転させる\var{negl}命令をジャンプするようにした。以上のようにして，符号反転キーの処理を行った。

ここで，ジャンプ用のラベルとして1, というのを用いているが，これはローカルラベルである。これを用いた理由は，この命令は複数回出力されるため，グローバルラベルを用いるとラベル名の衝突によるエラーが発生してしまうからである。

また，その後の演算は\var{lastOp}に記録された演算子に対応するアセンブリ命令を用いるだけであるが，割り算の場合においては若干実装に工夫があるので，それについて述べる。
割り算のとき，負数の取り扱いのために符号拡張を行う必要がある。講義資料では\var{eax}レジスタの正負に合わせて\var{mov}命令により\var{edx}の上位ビットをセットする方法が紹介されていたが，今回は\var{cltd}命令を用いた。これにより，割り算の際に\var{eax}の符号に合わせて\var{mov}命令でセットする値を変更する，というコードを書かなくて良くなり，コードが簡潔になった。

\subsection{メモリ機能の管理}
メモリ機能の管理については，calc0で述べた実装をそのままアセンブリに置き換えたのみである。メモリの値についてはスタックの先頭に積むことにしたので，メモリの値を書き換える必要がある時は\var{rdx}レジスタに読み出して処理を行ったのち，スタックに積み直すようにした。

\subsection{その他の部分}
コードの終了部分では，計算結果を返すために，講義資料で示された例に従ってprintfを呼び出している。また，資料の例ではプログラムの終了のために\var{ret}命令を用いていたが，今回はexitを呼び出すことでプログラムを終了させるようにした。
コードの終了部分の工夫として，スタックに積んでいた\var{mem}と\var{countS}をポップするために，\var{pop}命令ではなく\var{add}命令を用いてスタックポインタを移動させるようにしたことが挙げられる。スタックポインタが指すアドレスをデータ2つ分スタックの下に移動することにより，\var{pop}命令を2回書かずともスタックの先頭2つのデータを削除することができる。

\section{calc2}
この章ではcalc2の実装について述べる。calc2ではcalc1での実装をベースに，オーバーフロー検知や0割り検知を行うようにした。本章では，calc1から変更された実装について述べる。

\subsection{オーバーフロー検知}
オーバーフローの検知は，演算子の処理部分で各演算子に対応する命令を実行した後と数値入力の処理のための命令を実行した後に\var{jo overflow}を使用することで行う。これにより，種々の計算によってオーバーフローフラグがセットされた時に，オーバーフロー時の対応を行うための処理ブロックにジャンプすることができる。

\var{overflow}ラベル以下での処理は以下の通りである。まず，\var{leaq}命令によりエラーメッセージ(今回は単にEのみ)をセットし，\var{call}命令でprintfを呼び出してエラーメッセージを表示する。その後，exitステータスとして1をセットした上で\var{call}命令でexitを呼び出してプログラムを終了させる。

\subsection{0割り検知}
0割りの検知は，\var{idiv}命令を実行する前に\var{cmpl \$0, \%ecx}と\var{je division\_by\_zero}を実行することで0割りの検知を行う。\var{cmpl}命令を実行することで，\var{ecx}がゼロであればゼロフラグがセットされるので，その次の\var{je}命令で条件分岐することができる。

division\_by\_zero以下の処理は，オーバーフロー検知時と同様である。

\section{calc3}
この章ではcalc3の実装について述べる。calc3では，calc1の実装をベースに\var{imull}命令と\var{idiv}命令を用いずに乗除を表すことを目指した。本章では，calc1から変更された実装について述べる。

\subsection{乗算の実装}
\var{imull}を用いない乗算について，正数同士の掛け算と符号の処理に分けて実装した。

まず，正数同士の掛け算の実装について説明する。この実装では，\var{ecx}に格納されている乗数と\var{eax}に格納されている被乗数を用いて，ビットシフトとキャリーフラグを用いることで乗算を実現している。少し込み入った手順であるため，以下に番号付き箇条書きで用いた命令とその意図について述べる。

\begin{enumerate}
    \item \var{rcrl \$1, \%ecx}: 乗数\var{ecx}を1ビット右回転させる。この操作により，乗数の最下位ビットがキャリーフラグ（CF）に移動する。これは，掛け算の筆算での，下一桁を取り出して，その掛け算を考えるという動作を実現するためである。
    \item \var{jnc 3f}: CFがクリアであれば，次の加算処理をスキップする。これは，乗数の最下位ビットが0の場合は被乗数に0を掛ける処理をすることになり，そのような処理は最終的な値に影響を与えないからである。
    \item \var{addl \%eax, \%edx}: CFがセットされている場合（乗数の最下位ビットが1の場合），結果を保持するレジスタ\var{edx}に被乗数\var{eax}を加算する。
    \item \var{shll \$1, \%eax}: 被乗数\var{eax}を1ビット左シフトする。これは，乗数の次の桁に対応するための処理である。2進数では，桁が1つ左にシフトすると値が2倍になるため，乗算における桁上がりを表現できる。筆算で言えば，桁ごとの掛け算の結果ごとに一つずつ位をずらして書くという操作に相当する。
    \item \var{testl \%ecx, \%ecx} and \var{jnz 2b}: 乗数\var{ecx}が0になるまで，ステップ1から4を繰り返す。\var{ecx}が0になるということは見るべき桁がなくなったこと，つまり乗数の全てのビットを処理したことを意味する。
\end{enumerate}

続いて，符号処理の実装方法について考える。calc2までのように先んじて乗数の符号を変えてしまうと，2の補数表現を用いている間係でうまくいかないケースが出てきてしまうと考え，乗数と被乗数の符号をまとめて処理することにした。
具体的な実装としては，まず，\var{test}命令を用いることで，被乗数\var{eax}の符号をチェックする。もし被乗数が負の数であれば，\var{negl}命令を用いて被乗数を正の数に変換すした上で，countSをインクリメントする。そして乗算が終了したタイミングで，計算結果の正負をcountSに応じて調整する。こうすることで，被乗数の正負の情報をcountSに渡し，まとめて処理することができる。

以上のような\var{imull}を用いない乗算の実装のポイントは，乗数の最下位ビットを見るために\var{rcr}命令を用いたことである。これにより，例えばシフトしてから\var{and}命令を用いるなどの余分な動作をせず，短いコードで確実に乗算を行えるようになった。また，掛け算の筆算における，各桁ごとの掛け算の結果を1桁ずつずらして書いて最後に足しこむ，という動作を被乗数を左シフトすることにより実装したことは，かなり直感的で分かりやすい実装であると考えている。

また，被乗数と乗数の符号の情報をcountSにまとめ，最後に処理するという実装も，最も大変な掛け算の実装のロジックに複雑な場合分を入れなくて済むという点で優れている。

\subsection{除算の実装}

\var{idivl}を用いない除算について，乗算と同様に正数同士の割り算と符号の処理に分けて実装した。

まず，正数同士の割り算の実装について説明する。この実装では，\var{eax}に格納されている被除数，\var{ecx}に格納されている除数を用いて，ビットシフトと減算を用いることで除算を実現している。以下に番号付き箇条書きで用いた命令とその意図について述べる。

\begin{enumerate}
\item \var{xorl \%edi, \%edi}:部分剰余を格納するレジスタ\var{edi}を0クリアする。
\item \var{movl \%ecx, \%edx}:除数\var{ecx}の値を\var{edx}にコピーする。\var{ecx}はループカウンタとして使用するため，除数の値を保持するために\var{edx}を用いる。
\item \var{movl \$32, \%ecx}:ループカウンタ\var{ecx}に32を設定する。カウンタを32にするのは，除算を行うために1ビットずつ見ていく必要があるからであり，かつ今回は32ビット整数を扱うからである。
\item \var{xorl \%esi, \%esi}:商を格納するレジスタ\var{esi}を0クリアする。
\item \var{shll \$1, \%eax}:被除数\var{eax}を1ビット左シフトする。
\item \var{rcll \$1, \%edi}:\var{eax}の最上位ビットをキャリーフラグを介して部分剰余\var{edi}に移動させる。これは，部分剰余に被除数のビットを1つずつ取り込んでいく処理であり，これは割り算の筆算で上の桁から一桁ずつずらして商が立つところを探す動作に相当する。
\item \var{shll \$1, \%esi}:商\var{esi}を1ビット左シフトする。これは，割り算の筆算で数字を立てる桁を一つずつ下にずらしていく動作に相当する。
\item \var{cmpl \%edx, \%edi}:部分剰余\var{edi}と除数\var{edx}を比較する。
\item \var{jl 3f}:部分剰余が除数より小さい場合，次の減算処理をスキップする。
\item \var{addl \$1, \%esi}:部分剰余が除数以上の場合，商\var{esi}に1を加算する。これは，割り算の筆算で数字を立てることに相当する。
\item \var{subl \%edx, \%edi}:部分剰余\var{edi}から除数\var{edx}を減算する。
\item \var{decl \%ecx}:ループカウンタ\var{ecx}をデクリメントする。
\item \var{testl \%ecx, \%ecx} and \var{jnz 2b}:ループカウンタ\var{ecx}が0になるまで，ステップ5から12を繰り返す。
\end{enumerate}

続いて，符号処理の実装方法について説明する。乗算の場合と同様に，被除数と除数の符号をまとめて処理するために，被除数の符号を\var{test}命令でチェックし，負の数であれば\var{negl}命令で正の数に変換し，countSをインクリメントする。そして除算が終了したタイミングで，計算結果の正負をcountSに応じて調整する。

以上のような\var{idiv}を用いない除算の実装のポイントは，乗算の場合と同様に，\var{rcl}命令によるシンプルな手法に被除数の値を見ることができる点である。また，これらの動作は割り算の筆算の手法を直感的に表現しており，理解しやすい実装であると考えている。


\section{反省}
- 命令やレジスタが本当に高速になっているのかを計測して確かめていない。
\end{document}